### 最短路问题的最优子结构


>[!abstract] 从动态规划的角度看 
最短路问题，以单源最短路为例
可以分为每个点距离原点为路径为1条的最短路
......
可以分为每个点距离原点为路径为n条的最短路
假设共 n 个点，求距离原点距离为 i 条路径的到 j 点的距离
f[i]\[j]  = min (f[i - 1]\[k] + d[k]\[j])   以此类推
故以此为基础, 其余最短算法为此法的分支与优化



### 与朴素 dijstra 的联系（处理的都是正权边）

>[!quote] 
>故由上述算法流程可知，每 i 轮找到的是点 j 距离原点距离路径为 i 条的最短路。
>Dijstra 算法用于求所有点距离原点的最短距离, 流程如下, 令总共 N 个点,已找到最短距离的点集为 P, 未找到的为 Q
>
>R 1, 从 Q 找到距离原点路径长度最多为 1 的最短距离的点, 并加入 P, 并更新原点到所有点的距离
>R2, 从 Q 找到距离原点路径长度最多为 2 的最短距离的点, ~
>....
>R 3, 从 Q 找到距离原点路径长度最多为 N - 1 的最短距离的点, ~

#### dijstra 的使用范围

单源最短路（“单源”很妙), 无负环图，可用于判定图中是否有负环


#### 论证 (条件, 处理的都是正权边)

设源点为 s, 第一轮时，得到的便是从原点到经过一条边可达所有点, 设点集设为 V 1，经过的所有边的边集设为 U 1，则从中挑选最短的边 Esv, v 点在该轮计算出来的距离亦是从原点该点 v 的最短的距离, 如要找到第二个点到原点的最短距离，则只须将 v 点经过一点边可达的所有点 u V 1, 令该点集为 V 2, 再将 v 点到这些点的边（除去 Esv）+Esv 的距离的到的
边 u U 1, 所得的边集记为 U 2 (除去 Esv)，则从中挑选最短的边 Esp, 则此时 Esp 边便是从源点 s 到点 p 的最短距离,
然后再将点 p 经过一点边可达的所点......

便能找到源点距离所有点的最短距离


### 与 bellman-ford的联系

>[!quote] 
>故由上述算法流程可知，每 i 轮找的是 j 点距离原点距离路径为 i条的最短路。
>Bellman-ford 算法用于求所有点距离原点的最短距离, 流程如下, 令总共 N 个点,已找到最短距离的点集为 P, 未找到的为 Q
>1)初始化所有点到源点的距离为∞, 把源点到自己的距离设置为 0；
 2)遍历 n 次; 每次遍历 m 条边，用每一条边去更新各点到源点的距离, 即松弛操作。

####  bellman-ford 的使用范围

搜索无负权环的带权有向图的单源节点到其他节点的所有最短路径。检测负权环。

#### 证明






